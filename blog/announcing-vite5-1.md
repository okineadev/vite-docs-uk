---
title: Vite 5.1 вийшов!
author:
  name: Команда Vite
date: 2024-02-08
sidebar: false
head:
  - - meta
    - property: og:type
      content: website
  - - meta
    - property: og:title
      content: Оголошення Vite 5.1
  - - meta
    - property: og:image
      content: https://vite.dev/og-image-announcing-vite5-1.png
  - - meta
    - property: og:url
      content: https://vite.dev/blog/announcing-vite5-1
  - - meta
    - property: og:description
      content: Оголошення про випуск Vite 5.1
  - - meta
    - name: twitter:card
      content: summary_large_image
---

# Vite 5.1 вийшов!

_8 лютого 2024 року_

![Зображення оголошення Vite 5.1](/og-image-announcing-vite5-1.png)

Vite 5 [був випущений](./announcing-vite5.md) минулого листопада, і це стало ще одним великим кроком вперед для Vite та екосистеми. Кілька тижнів тому ми святкували 10 мільйонів щотижневих завантажень npm та 900 учасників у репозиторії Vite. Сьогодні ми раді оголосити про випуск Vite 5.1.

Швидкі посилання: [Документація](/), [Зміни](https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md#510-2024-02-08)

Документація іншими мовами: [简体中文](https://cn.vite.dev/), [日本語](https://ja.vite.dev/), [Español](https://es.vite.dev/), [Português](https://pt.vite.dev/), [한국어](https://ko.vite.dev/), [Deutsch](https://de.vite.dev/)

Спробуйте Vite 5.1 онлайн у StackBlitz: [vanilla](https://vite.new/vanilla-ts), [vue](https://vite.new/vue-ts), [react](https://vite.new/react-ts), [preact](https://vite.new/preact-ts), [lit](https://vite.new/lit-ts), [svelte](https://vite.new/svelte-ts), [solid](https://vite.new/solid-ts), [qwik](https://vite.new/qwik-ts).

Якщо ви новачок у Vite, ми рекомендуємо спочатку прочитати [Початок роботи](/guide/) та [Особливості](/guide/features).

Щоб бути в курсі новин, слідкуйте за нами на [X](https://x.com/vite_js) або [Mastodon](https://webtoo.ls/@vite).

## API виконання Vite

Vite 5.1 додає експериментальну підтримку нового API виконання Vite. Це дозволяє виконувати будь-який код, обробляючи його спочатку за допомогою плагінів Vite. Це відрізняється від `server.ssrLoadModule`, оскільки реалізація виконання відокремлена від сервера. Це дозволяє авторам бібліотек та фреймворків реалізовувати власний шар комунікації між сервером та виконанням. Це нове API призначене для заміни поточних примітивів SSR Vite після його стабілізації.

Нове API приносить багато переваг:

- Підтримка HMR під час SSR.
- Воно відокремлене від сервера, тому немає обмежень на кількість клієнтів, які можуть використовувати один сервер - кожен клієнт має власний кеш модулів (ви навіть можете спілкуватися з ним як завгодно - використовуючи канал повідомлень/виклик fetch/прямий виклик функції/websocket).
- Воно не залежить від жодних вбудованих API node/bun/deno, тому може працювати в будь-якому середовищі.
- Легко інтегрується з інструментами, які мають власний механізм виконання коду (ви можете надати виконавця для використання `eval` замість `new AsyncFunction`, наприклад).

Початкова ідея [була запропонована Пуйя Парса](https://github.com/nuxt/vite/pull/201) та реалізована [Ентоні Фу](https://github.com/antfu) як пакет [vite-node](https://github.com/vitest-dev/vitest/tree/main/packages/vite-node#readme) для [підтримки Nuxt 3 Dev SSR](https://antfu.me/posts/dev-ssr-on-nuxt) і пізніше також використана як основа для [Vitest](https://vitest.dev). Отже, загальна ідея vite-node була перевірена в бою протягом тривалого часу. Це нова ітерація API від [Володимира Шеремета](https://github.com/sheremet-va), який вже реалізував vite-node у Vitest і взяв уроки, щоб зробити API ще більш потужним та гнучким при додаванні його до Vite Core. PR був у розробці протягом року, ви можете побачити еволюцію та обговорення з підтримувачами екосистеми [тут](https://github.com/vitejs/vite/issues/12165).

::: info
API виконання Vite еволюціонувало в API запуску модулів, випущене у Vite 6 як частина [API середовища](/guide/api-environment).
:::

## Особливості

### Покращена підтримка `.css?url`

Імпорт CSS файлів як URL тепер працює надійно та правильно. Це була остання перешкода на шляху переходу Remix на Vite. Дивіться ([#15259](https://github.com/vitejs/vite/issues/15259)).

### `build.assetsInlineLimit` тепер підтримує зворотний виклик

Користувачі тепер можуть [надати зворотний виклик](/config/build-options.html#build-assetsinlinelimit), який повертає булеве значення для вибору вбудовування для конкретних ресурсів. Якщо повертається `undefined`, застосовується стандартна логіка. Дивіться ([#15366](https://github.com/vitejs/vite/issues/15366)).

### Покращений HMR для циклічного імпорту

У Vite 5.0 прийняті модулі в циклічних імпортах завжди викликали повне перезавантаження сторінки, навіть якщо вони могли бути оброблені на клієнті. Тепер це обмеження знято, щоб дозволити HMR застосовуватися без повного перезавантаження сторінки, але якщо під час HMR виникає помилка, сторінка буде перезавантажена. Дивіться ([#15118](https://github.com/vitejs/vite/issues/15118)).

### Підтримка `ssr.external: true` для зовнішнього підключення всіх пакетів SSR

Історично Vite зовнішньо підключає всі пакети, крім пов'язаних пакетів. Ця нова опція може бути використана для примусового зовнішнього підключення всіх пакетів, включаючи пов'язані пакети. Це зручно в тестах у монорепозиторіях, де ми хочемо імітувати звичайний випадок зовнішнього підключення всіх пакетів, або при використанні `ssrLoadModule` для завантаження довільного файлу, і ми хочемо завжди зовнішньо підключати пакети, оскільки нам не важливо про HMR. Дивіться ([#10939](https://github.com/vitejs/vite/issues/10939)).

### Відкриття методу `close` у сервері попереднього перегляду

Сервер попереднього перегляду тепер відкриває метод `close`, який правильно завершує роботу сервера, включаючи всі відкриті з'єднання сокетів. Дивіться ([#15630](https://github.com/vitejs/vite/issues/15630)).

## Покращення продуктивності

Vite стає швидшим з кожним випуском, і Vite 5.1 наповнений покращеннями продуктивності. Ми виміряли час завантаження для 10K модулів (дерево з 25 рівнями) за допомогою [vite-dev-server-perf](https://github.com/yyx990803/vite-dev-server-perf) для всіх мінорних версій з Vite 4.0. Це хороший бенчмарк для вимірювання ефекту підходу Vite без пакетування. Кожен модуль - це невеликий файл TypeScript з лічильником та імпортами до інших файлів у дереві, тому це в основному вимірює час, необхідний для виконання запитів окремих модулів. У Vite 4.0 завантаження 10K модулів займало 8 секунд на M1 MAX. Ми досягли прориву у [Vite 4.3, де ми зосередилися на продуктивності](./announcing-vite4-3.md), і змогли завантажити їх за 6.35 секунд. У Vite 5.1 ми зробили ще один стрибок у продуктивності. Тепер Vite обслуговує 10K модулів за 5.35 секунд.

![Прогрес часу завантаження 10K модулів Vite](/vite5-1-10K-modules-loading-time.png)

Результати цього бенчмарку виконані на Headless Puppeteer і є хорошим способом порівняння версій. Вони не представляють час, якого зазнають користувачі. При запуску тих самих 10K модулів у вікні інкогніто в Chrome ми маємо:

| 10K модулів           | Vite 5.0 | Vite 5.1 |
| --------------------- | :------: | :------: |
| Час завантаження      |  2892ms  |  2765ms  |
| Час завантаження (кеш) |  2778ms  |  2477ms  |
| Повне перезавантаження |  2003ms  |  1878ms  |
| Повне перезавантаження (кеш) |  1682ms  |  1604ms  |

### Запуск препроцесорів CSS у потоках

Тепер Vite має підтримку запуску препроцесорів CSS у потоках. Ви можете увімкнути це за допомогою [`css.preprocessorMaxWorkers: true`](/config/shared-options.html#css-preprocessormaxworkers). Для проекту Vuetify 2 час запуску розробки зменшився на 40% з увімкненою цією функцією. Є [порівняння продуктивності для інших налаштувань у PR](https://github.com/vitejs/vite/pull/13584#issuecomment-1678827918). Дивіться ([#13584](https://github.com/vitejs/vite/issues/13584)). [Залишити відгук](https://github.com/vitejs/vite/discussions/15835).

### Нові опції для покращення холодного старту сервера

Ви можете встановити `optimizeDeps.holdUntilCrawlEnd: false`, щоб переключитися на нову стратегію оптимізації залежностей, яка може допомогти у великих проектах. Ми розглядаємо можливість переходу на цю стратегію за замовчуванням у майбутньому. [Залишити відгук](https://github.com/vitejs/vite/discussions/15834). ([#15244](https://github.com/vitejs/vite/issues/15244))

### Швидше вирішення з кешованими перевірками

Оптимізація `fs.cachedChecks` тепер увімкнена за замовчуванням. У Windows `tryFsResolve` був приблизно в 14 разів швидшим з нею, а вирішення ідентифікаторів загалом отримало приблизно 5-кратне прискорення у трикутному бенчмарку. ([#15704](https://github.com/vitejs/vite/issues/15704))

### Внутрішні покращення продуктивності

Сервер розробки отримав кілька поступових покращень продуктивності. Нова проміжна програма для короткого замикання на 304 ([#15586](https://github.com/vitejs/vite/issues/15586)). Ми уникнули `parseRequest` у гарячих шляхах ([#15617](https://github.com/vitejs/vite/issues/15617)). Rollup тепер правильно завантажується ліниво ([#15621](https://github.com/vitejs/vite/issues/15621))

## Депрекації

Ми продовжуємо зменшувати поверхню API Vite, де це можливо, щоб зробити проект підтримуваним у довгостроковій перспективі.

### Депрековано опцію `as` у `import.meta.glob`

Стандарт перейшов на [Атрибути імпорту](https://github.com/tc39/proposal-import-attributes), але ми не плануємо замінювати `as` новою опцією на даний момент. Натомість рекомендується, щоб користувач перейшов на `query`. Дивіться ([#14420](https://github.com/vitejs/vite/issues/14420)).

### Видалено експериментальне попереднє пакетування під час збірки

Попереднє пакетування під час збірки, експериментальна функція, додана у Vite 3, видалена. З переходом Rollup 4 на рідний парсер і роботою над Rolldown, як продуктивність, так і історія невідповідності dev-vs-build для цієї функції більше не є дійсними. Ми хочемо продовжувати покращувати узгодженість dev/build і дійшли висновку, що використання Rolldown для "попереднього пакетування під час розробки" та "виробничих збірок" є кращим варіантом у майбутньому. Rolldown також може реалізувати кешування таким чином, що буде набагато ефективнішим під час збірки, ніж попереднє пакетування залежностей. Дивіться ([#15184](https://github.com/vitejs/vite/issues/15184)).

## Долучайтеся

Ми вдячні [900 учасникам Vite Core](https://github.com/vitejs/vite/graphs/contributors) та підтримувачам плагінів, інтеграцій, інструментів та перекладів, які продовжують просувати екосистему вперед. Якщо вам подобається Vite, ми запрошуємо вас долучитися та допомогти нам. Ознайомтеся з нашим [Посібником з внесків](https://github.com/vitejs/vite/blob/main/CONTRIBUTING.md) і приєднуйтеся до [тріажу проблем](https://github.com/vitejs/vite/issues), [перегляду PR](https://github.com/vitejs/vite/pulls), відповідей на запитання у [GitHub Discussions](https://github.com/vitejs/vite/discussions) та допомоги іншим у спільноті у [Vite Land](https://chat.vite.dev).

## Подяки

Vite 5.1 став можливим завдяки нашій спільноті учасників, підтримувачам екосистеми та [Команді Vite](/team). Особлива подяка особам та компаніям, які спонсорують розробку Vite. [StackBlitz](https://stackblitz.com/), [Nuxt Labs](https://nuxtlabs.com/) та [Astro](https://astro.build) за наймання членів команди Vite. А також спонсорам на [GitHub Sponsors Vite](https://github.com/sponsors/vitejs), [Open Collective Vite](https://opencollective.com/vite) та [GitHub Sponsors Evan You](https://github.com/sponsors/yyx990803).
