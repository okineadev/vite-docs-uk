# Посібник з внеску до Vite

Привіт! Ми дуже раді, що ви зацікавлені у внеску до Vite! Перед тим, як подати свій внесок, будь ласка, прочитайте цей посібник. Також рекомендуємо ознайомитися з [Філософією проекту](https://vitejs.dev/guide/philosophy) у нашій документації.

Ви можете використовувати [StackBlitz Codeflow](https://stackblitz.com/codeflow) для виправлення помилок або реалізації функцій. Ви побачите кнопку Codeflow на завданнях, щоб розпочати PR для їх виправлення. Кнопка також з'явиться на PR для їх перегляду без необхідності перевіряти гілку локально. Використовуючи Codeflow, репозиторій Vite буде клоновано для вас в онлайн-редакторі, з пакетом Vite, зібраним у режимі спостереження, готовим для тестування ваших змін. Якщо ви хочете дізнатися більше, ознайомтеся з [документацією Codeflow](https://developer.stackblitz.com/codeflow/what-is-codeflow).

[![Відкрити в Codeflow](https://developer.stackblitz.com/img/open_in_codeflow.svg)](https://pr.new/vitejs/vite)

## Налаштування репозиторію

Для локальної розробки, форкніть репозиторій Vite та клонуйте його на свій локальний комп'ютер. Репозиторій Vite є монорепозиторієм, що використовує робочі простори pnpm. Менеджер пакетів, який використовується для встановлення та зв'язування залежностей, має бути [pnpm](https://pnpm.io/).

Для розробки та тестування основного пакету `vite`:

1. Запустіть `pnpm i` у кореневій папці Vite.

2. Запустіть `pnpm run build` у кореневій папці Vite.

3. Якщо ви розробляєте сам Vite, ви можете перейти до `packages/vite` та запустити `pnpm run dev`, щоб автоматично перебудовувати Vite щоразу, коли ви змінюєте його код.

Ви також можете використовувати [Vite.js Docker Dev](https://github.com/nystudio107/vitejs-docker-dev) для контейнеризованого налаштування Docker для розробки Vite.js.

> Vite використовує pnpm v8. Якщо ви працюєте над кількома проектами з різними версіями pnpm, рекомендується увімкнути [Corepack](https://github.com/nodejs/corepack), запустивши `corepack enable`.

### Ігнорування комітів при запуску `git blame`

У нас є файл `.git-blame-ignore-revs` для ігнорування змін форматування.
Щоб цей файл використовувався `git blame`, вам потрібно виконати наступну команду.

```sh
git config --local blame.ignoreRevsFile .git-blame-ignore-revs
```

## Налагодження

Щоб використовувати точки зупину та досліджувати виконання коду, ви можете використовувати функцію ["Запуск та налагодження"](https://code.visualstudio.com/docs/editor/debugging) у VS Code.

1. Додайте оператор `debugger` там, де ви хочете зупинити виконання коду.

2. Натисніть іконку "Запуск та налагодження" на панелі активності редактора, що відкриє [_Перегляд запуску та налагодження_](https://code.visualstudio.com/docs/editor/debugging#_run-and-debug-view).

3. Натисніть кнопку "Термінал налагодження JavaScript" у _Перегляді запуску та налагодження_, що відкриє термінал у VS Code.

4. З цього терміналу перейдіть до `playground/xxx` та запустіть `pnpm run dev`.

5. Виконання зупиниться на операторі `debugger`, і ви можете використовувати [Панель налагодження](https://code.visualstudio.com/docs/editor/debugging#_debug-actions) для продовження, крокування та перезапуску процесу...

### Налагодження помилок у тестах Vitest за допомогою Playwright (Chromium)

Деякі помилки приховані через шари абстракції та ізольовану природу, додану Vitest, Playwright та Chromium. Щоб побачити, що насправді йде не так і вміст консолі devtools у таких випадках, дотримуйтесь цього налаштування:

1. Додайте оператор `debugger` до `playground/vitestSetup.ts` -> хука `afterAll`. Це призупинить виконання перед завершенням тестів і виходом з екземпляра браузера Playwright.

2. Запустіть тести з командою `debug-serve`, яка дозволить віддалене налагодження: `pnpm run debug-serve resolve`.

3. Дочекайтеся відкриття інструментів налагодження у вашому браузері та підключення налагоджувача.

4. У панелі джерел у правій колонці натисніть кнопку відтворення, щоб продовжити виконання, і дозвольте тестам запуститися, що відкриє екземпляр Chromium.

5. Зосередившись на екземплярі Chromium, ви можете відкрити інструменти розробника браузера та перевірити консоль, щоб знайти основні проблеми.

6. Щоб закрити все, просто зупиніть процес тестування у вашому терміналі.

## Тестування Vite з зовнішніми пакетами

Ви можете захотіти протестувати свою локально змінену копію Vite з іншим пакетом, який побудований за допомогою Vite. Для pnpm, після побудови Vite, ви можете використовувати [`pnpm.overrides`](https://pnpm.io/package_json#pnpmoverrides) для цього. Зверніть увагу, що `pnpm.overrides` має бути вказано у кореневому `package.json`, і ви повинні вказати пакет як залежність у кореневому `package.json`:

```json
{
    "dependencies": {
        "vite": "^4.0.0"
    },
    "pnpm": {
        "overrides": {
            "vite": "link:../path/to/vite/packages/vite"
        }
    }
}
```

І повторно запустіть `pnpm install`, щоб зв'язати пакет.

## Запуск тестів

### Інтеграційні тести

Кожен пакет у `playground/` містить директорію `__tests__`. Тести запускаються за допомогою [Vitest](https://vitest.dev/) + [Playwright](https://playwright.dev/) з користувацькими інтеграціями, щоб зробити написання тестів простим. Детальне налаштування знаходиться у файлах `vitest.config.e2e.js` та `playground/vitest*`.

Деякі ігрові майданчики визначають варіанти для запуску того ж додатку з різними налаштуваннями конфігурації. За конвенцією, при запуску файлу тестової специфікації у вкладеній папці у `__tests__`, налаштування спробує використовувати файл конфігурації з назвою `vite.config-{folderName}.js` у корені ігрового майданчика. Ви можете побачити приклад варіантів у [ігровому майданчику assets](https://github.com/vitejs/vite/tree/main/playground/assets).

Перед запуском тестів переконайтеся, що [Vite було побудовано](#налаштування-репозиторію). На Windows, можливо, вам знадобиться [активувати режим розробника](https://docs.microsoft.com/en-us/windows/apps/get-started/enable-your-device-for-development), щоб вирішити [проблеми зі створенням символічних посилань для неадміністраторів](https://github.com/vitejs/vite/issues/7390). Також, можливо, вам знадобиться [встановити git `core.symlinks` на `true`, щоб вирішити проблеми з символічними посиланнями у git](https://github.com/vitejs/vite/issues/5242).

Кожен інтеграційний тест можна запустити у режимі dev-сервера або у режимі збірки.

- `pnpm test` за замовчуванням запускає кожен інтеграційний тест у режимах serve та build, а також юніт-тести.

- `pnpm run test-serve` запускає тести лише у режимі serve.

- `pnpm run test-build` запускає тести лише у режимі build.

- `pnpm run test-serve [match]` або `pnpm run test-build [match]` запускає тести у конкретних пакетах, які відповідають заданому фільтру. Наприклад, `pnpm run test-serve asset` запускає тести для `playground/asset` та `vite/src/node/__tests__/asset` у режимі serve.

    Зверніть увагу, що відповідність пакетів недоступна для скрипту `pnpm test`, який завжди запускає всі тести.

### Юніт-тести

Крім тестів у `playground/` для інтеграційних тестів, пакети можуть містити юніт-тести у своїй директорії `__tests__`. Юніт-тести працюють за допомогою [Vitest](https://vitest.dev/). Детальна конфігурація знаходиться у файлах `vitest.config.ts`.

- `pnpm run test-unit` запускає юніт-тести у кожному пакеті.

- `pnpm run test-unit [match]` запускає тести у конкретних пакетах, які відповідають заданому фільтру.

### Тестове середовище та допоміжні засоби

У тестах ігрового майданчика ви можете імпортувати об'єкт `page` з `~utils`, який є екземпляром Playwright [`Page`](https://playwright.dev/docs/api/class-page), що вже перейшов на сторінку, яка обслуговується поточним ігровим майданчиком. Тому написання тесту таке просте, як:

```js
import { page } from '~utils'

test('має працювати', async () => {
    expect(await page.textContent('.foo')).toMatch('foo')
})
```

Деякі загальні допоміжні засоби для тестування (наприклад, `testDir`, `isBuild` або `editFile`) також доступні у утилітах. Вихідний код знаходиться у `playground/test-utils.ts`.

Примітка: тестове середовище збірки використовує [інший набір конфігурацій Vite за замовчуванням](https://github.com/vitejs/vite/blob/main/playground/vitestSetup.ts#L102-L122), щоб пропустити транспіляцію під час тестів, щоб зробити їх швидшими. Це може призвести до іншого результату порівняно зі стандартною збіркою для продакшну.

### Розширення тестового набору

Щоб додати нові тести, вам слід знайти пов'язаний ігровий майданчик для виправлення або функції (або створити новий). Наприклад, завантаження статичних ресурсів тестується у [ігровому майданчику assets](https://github.com/vitejs/vite/tree/main/playground/assets). У цьому додатку Vite є тест для імпортів `?raw` з [розділом, визначеним у `index.html` для цього](https://github.com/vitejs/vite/blob/main/playground/assets/index.html#L121):

```html
<h2>?raw import</h2>
<code class="raw"></code>
```

Це буде змінено [з результатом імпорту файлу](https://github.com/vitejs/vite/blob/main/playground/assets/index.html#L151):

```js
import rawSvg from './nested/fragment.svg?raw'
text('.raw', rawSvg)
```

...де утиліта `text` визначена як:

```js
function text(el, text) {
    document.querySelector(el).textContent = text
}
```

У [специфікаційних тестах](https://github.com/vitejs/vite/blob/main/playground/assets/__tests__/assets.spec.ts#L180), зміни до DOM, перераховані вище, використовуються для тестування цієї функції:

```js
test('?raw import', async () => {
    expect(await page.textContent('.raw')).toMatch('SVG')
})
```

## Примітка щодо залежностей тестів

У багатьох тестових випадках нам потрібно мокати залежності, використовуючи протоколи `link:` та `file:`. `pnpm` обробляє `link:` як символічні посилання, а `file:` як жорсткі посилання. Щоб тестувати залежності так, ніби вони були скопійовані в `node_modules`, використовуйте протокол `file:`. В іншому випадку використовуйте протокол `link:`.

Для моканої залежності переконайтеся, що ви додаєте префікс `@vitejs/test-` до назви пакета. Це дозволить уникнути можливих проблем, таких як хибно-позитивні сповіщення.

## Налагоджувальні логи

Ви можете встановити змінну середовища `DEBUG`, щоб увімкнути налагоджувальні логи (наприклад, `DEBUG="vite:resolve"`). Щоб побачити всі налагоджувальні логи, ви можете встановити `DEBUG="vite:*"`, але будьте обережні, це буде досить шумно. Ви можете запустити `grep -r "createDebugger('vite:" packages/vite/src/`, щоб побачити список доступних налагоджувальних областей.

## Керівництво щодо Pull Request

- Відгалужуйтеся від основної гілки (наприклад, `main`) і зливайтеся назад у цю гілку.

- Якщо додаєте нову функцію:

    - Додайте відповідний тестовий випадок.
    - Надайте переконливу причину для додавання цієї функції. Ідеально, якщо ви спочатку відкриєте пропозицію у вигляді issue і отримаєте її схвалення перед початком роботи.

- Якщо виправляєте помилку:

    - Якщо ви вирішуєте конкретну проблему, додайте `(fix #xxxx[,#xxxx])` (#xxxx - це ідентифікатор issue) у заголовок вашого PR для кращого журналу випусків (наприклад, `fix: update entities encoding/decoding (fix #3899)`).
    - Надайте детальний опис помилки у PR. Бажано живу демонстрацію.
    - Додайте відповідне тестове покриття, якщо це можливо.

- Допускається мати кілька невеликих комітів під час роботи над PR. GitHub може автоматично об'єднати їх перед злиттям.

- Переконайтеся, що тести проходять!

- Не турбуйтеся про стиль коду, якщо ви встановили залежності для розробки. Змінені файли автоматично форматуються за допомогою Prettier під час коміту (використовуючи [Git Hooks](https://git-scm.com/docs/githooks) через [simple-git-hooks](https://github.com/toplenboren/simple-git-hooks)).

- Заголовок PR повинен відповідати [конвенції повідомлень про коміти](./.github/commit-convention.md), щоб журнали змін могли генеруватися автоматично.

## Керівництво з обслуговування

> Наступний розділ в основному для обслуговувачів, які мають доступ до комітів, але корисно ознайомитися, якщо ви плануєте робити значні внески в кодову базу.

### Робочий процес тріажу issue

<picture>
    <source media="(prefers-color-scheme: dark)" srcset="./.github/issue-workflow-dark.png">
    <img src="./.github/issue-workflow.png">
</picture>

### Робочий процес перегляду Pull Request

<picture>
    <source media="(prefers-color-scheme: dark)" srcset="./.github/pr-workflow-dark.png">
    <img src="./.github/pr-workflow.png">
</picture>

## Примітки щодо залежностей

Vite прагне бути легким, і це включає усвідомлення кількості npm-залежностей та їх розміру.

Ми використовуємо Rollup для попереднього збирання більшості залежностей перед публікацією! Тому більшість залежностей, навіть тих, що використовуються у вихідному коді під час виконання, за замовчуванням повинні бути додані до `devDependencies`. Це також створює наступні обмеження, які ми повинні враховувати в кодовій базі.

### Використання `require()`

У деяких випадках ми навмисно використовуємо lazy-require деяких залежностей для покращення продуктивності запуску. Однак, зверніть увагу, що ми не можемо використовувати прості виклики `require('somedep')`, оскільки вони ігноруються у файлах ESM, тому залежність не буде включена у збірку, і фактичної залежності навіть не буде там під час публікації, оскільки вони знаходяться у `devDependencies`.

Замість цього використовуйте `(await import('somedep')).default`.

### Подумайте перед додаванням залежності

Більшість залежностей повинні бути додані до `devDependencies`, навіть якщо вони потрібні під час виконання. Деякі винятки:

- Пакети типів. Наприклад: `@types/*`.
- Залежності, які не можуть бути належним чином зібрані через бінарні файли. Наприклад: `esbuild`.
- Залежності, які постачають власні типи, що використовуються у власних публічних типах Vite. Наприклад: `rollup`.

Уникайте залежностей з великими транзитивними залежностями, які призводять до роздутих розмірів порівняно з функціональністю, яку вони надають. Наприклад, `http-proxy` сам по собі плюс `@types/http-proxy` займає трохи більше 1 МБ, але `http-proxy-middleware` тягне за собою купу залежностей, що робить його 7 МБ(!), коли мінімальне власне проміжне програмне забезпечення на основі `http-proxy` потребує лише кілька рядків коду.

### Забезпечення підтримки типів

Vite прагне бути повністю використовуваним як залежність у TypeScript-проекті (наприклад, він повинен надавати належні типи для VitePress), а також у `vite.config.ts`. Це означає, що технічно залежність, типи якої є відкритими, повинна бути частиною `dependencies`, а не `devDependencies`. Однак це також означає, що ми не зможемо зібрати її.

Щоб обійти це, ми вбудовуємо деякі з цих залежностей у `packages/vite/src/types`. Таким чином, ми можемо все ще відкривати типи, але збирати вихідний код залежності.

Використовуйте `pnpm run build-types-check`, щоб перевірити, що зібрані типи не залежать від типів у `devDependencies`.

Для типів, що використовуються як у клієнті, так і у вузлі, вони повинні бути додані до `packages/vite/types`. Ці типи не збираються і публікуються як є (хоча вони все ще вважаються внутрішніми). Типи залежностей у цій директорії (наприклад, `packages/vite/types/chokidar.d.ts`) застарілі і повинні бути додані до `packages/vite/src/types`.

### Подумайте перед додаванням ще однієї опції

У нас вже є багато опцій конфігурації, і ми повинні уникати вирішення проблеми шляхом додавання ще однієї. Перед додаванням опції, розгляньте, чи проблема:

- дійсно варта вирішення
- може бути вирішена за допомогою розумнішого значення за замовчуванням
- має обхідний шлях за допомогою існуючих опцій
- може бути вирішена за допомогою плагіна

## Випуск

Якщо у вас є доступ до публікації, нижче наведені кроки, які пояснюють, як зробити випуск для пакета. Є дві фази для кроку випуску: "Випуск" та "Публікація".

"Випуск" виконується локально для генерації журналів змін та тегів git:

1. Переконайтеся, що віддалений репозиторій для <https://github.com/vitejs/vite> встановлено як `origin`.
2. У кореневій гілці проекту `vite` `main` виконайте `git pull` та `pnpm i`, щоб оновити його.
3. Запустіть `pnpm release` і дотримуйтесь підказок, щоб зробити випуск для пакета. Це згенерує журнал змін, тег випуску git та відправить їх до `origin`. Ви можете запустити з прапором `--dry`, щоб перевірити це.
4. Після завершення команди вона надасть посилання на <https://github.com/vitejs/vite/actions/workflows/publish.yml>.
5. Натисніть на посилання, щоб відвідати сторінку, і дотримуйтесь наступних кроків нижче.

"Публікація" виконується на GitHub Actions для публікації пакета на npm:

1. Незабаром на сторінці робочих процесів з'явиться новий робочий процес для випущеного пакета, який чекає на схвалення для публікації на npm.
2. Натисніть на робочий процес, щоб відкрити його сторінку.
3. Натисніть кнопку "Review deployments" у жовтому полі, з'явиться спливаюче вікно.
4. Виберіть "Release" і натисніть "Approve and deploy".
5. Пакет почне публікуватися на npm.

## Внесок у переклад документації

Щоб додати нову мову до документації Vite, дивіться [`vite-docs-template`](https://github.com/tony19/vite-docs-template/blob/main/.github/CONTRIBUTING.md).
