# Чому Vite

## Проблеми

До того, як ES модулі стали доступні в браузерах, розробники не мали нативного механізму для створення JavaScript у модульному вигляді. Саме тому ми всі знайомі з концепцією "бандлінгу": використання інструментів, які сканують, обробляють і об'єднують наші вихідні модулі у файли, які можуть виконуватися в браузері.

З часом ми побачили інструменти, такі як [webpack](https://webpack.js.org/), [Rollup](https://rollupjs.org) та [Parcel](https://parceljs.org/), які значно покращили досвід розробки для фронтенд-розробників.

Однак, коли ми створюємо все більш амбітні додатки, кількість JavaScript, з якою ми маємо справу, також значно зростає. Не рідкість для великих проектів містити тисячі модулів. Ми починаємо стикатися з проблемою продуктивності для інструментів на основі JavaScript: часто потрібно надто багато часу (іноді до кількох хвилин!), щоб запустити dev-сервер, і навіть з Hot Module Replacement (HMR) зміни файлів можуть займати кілька секунд, щоб відобразитися в браузері. Повільний цикл зворотного зв'язку може значно вплинути на продуктивність і задоволення розробників.

Vite прагне вирішити ці проблеми, використовуючи нові досягнення в екосистемі: доступність нативних ES модулів у браузері та зростання інструментів JavaScript, написаних на мовах, що компілюються в нативний код.

### Повільний запуск сервера

При холодному запуску dev-сервера, налаштування збірки на основі бандлера повинно заздалегідь сканувати і збирати весь ваш додаток перед тим, як його можна буде обслуговувати.

Vite покращує час запуску dev-сервера, спочатку розділяючи модулі в додатку на дві категорії: **залежності** та **вихідний код**.

- **Залежності** - це в основному простий JavaScript, який не часто змінюється під час розробки. Деякі великі залежності (наприклад, бібліотеки компонентів з сотнями модулів) також досить дорогі в обробці. Залежності можуть також постачатися в різних форматах модулів (наприклад, ESM або CommonJS).

  Vite [попередньо збирає залежності](./dep-pre-bundling) за допомогою [esbuild](https://esbuild.github.io/). esbuild написаний на Go і попередньо збирає залежності в 10-100 разів швидше, ніж бандлери на основі JavaScript.

- **Вихідний код** часто містить не простий JavaScript, який потребує трансформації (наприклад, JSX, CSS або компоненти Vue/Svelte), і буде часто редагуватися. Також не весь вихідний код потрібно завантажувати одночасно (наприклад, з розбиттям коду на основі маршрутів).

  Vite обслуговує вихідний код через [нативний ESM](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules). Це по суті дозволяє браузеру взяти на себе частину роботи бандлера: Vite потрібно лише трансформувати і обслуговувати вихідний код на вимогу, коли браузер його запитує. Код за умовними динамічними імпортами обробляється лише тоді, коли він фактично використовується на поточному екрані.

<script setup>
import bundlerSvg from '../images/bundler.svg?raw'
import esmSvg from '../images/esm.svg?raw'
</script>
<svg-image :svg="bundlerSvg" />
<svg-image :svg="esmSvg" />

### Повільні оновлення

Коли файл редагується в налаштуванні збірки на основі бандлера, неефективно перебудовувати весь бандл з очевидної причини: швидкість оновлення буде погіршуватися лінійно зі збільшенням розміру додатку.

У деяких бандлерах dev-сервер виконує збірку в пам'яті, тому йому потрібно лише анулювати частину графа модулів, коли файл змінюється, але все одно потрібно перебудовувати весь бандл і перезавантажувати веб-сторінку. Перебудова бандла може бути дорогою, а перезавантаження сторінки знищує поточний стан додатку. Саме тому деякі бандлери підтримують Hot Module Replacement (HMR): дозволяючи модулю "гаряче замінювати" себе без впливу на решту сторінки. Це значно покращує досвід розробки - однак, на практиці ми виявили, що навіть швидкість оновлення HMR значно погіршується зі збільшенням розміру додатку.

У Vite HMR виконується через нативний ESM. Коли файл редагується, Vite потрібно лише точно анулювати ланцюг між редагованим модулем і його найближчою межею HMR (найчастіше лише сам модуль), що робить оновлення HMR стабільно швидкими незалежно від розміру вашого додатку.

Vite також використовує HTTP заголовки для прискорення повного перезавантаження сторінки (знову ж таки, дозволяючи браузеру виконувати більше роботи за нас): запити на модулі вихідного коду робляться умовними через `304 Not Modified`, а запити на модулі залежностей сильно кешуються через `Cache-Control: max-age=31536000,immutable`, щоб вони більше не зверталися до сервера після кешування.

Як тільки ви відчуєте, наскільки швидкий Vite, ми дуже сумніваємося, що ви захочете знову працювати з бандлінгом під час розробки.

## Чому бандлінг для продакшну

Хоча нативний ESM зараз широко підтримується, доставка небандлінгового ESM у продакшні все ще неефективна (навіть з HTTP/2) через додаткові мережеві запити, викликані вкладеними імпортами. Для досягнення оптимальної продуктивності завантаження в продакшні все ще краще бандлити ваш код з tree-shaking, lazy-loading і розбиттям загальних частин (для кращого кешування).

Забезпечення оптимального виходу і поведінкової узгодженості між dev-сервером і продакшн-збіркою не є легким завданням. Саме тому Vite постачається з попередньо налаштованою [командою збірки](./build), яка включає багато [оптимізацій продуктивності](./features#build-optimizations) з коробки.

## Чому не бандлити з esbuild?

Хоча Vite використовує esbuild для [попереднього бандлінгу деяких залежностей у dev](./dep-pre-bundling.md), Vite не використовує esbuild як бандлер для продакшн-збірок.

Поточний API плагінів Vite не сумісний з використанням `esbuild` як бандлера. Незважаючи на те, що `esbuild` швидший, прийняття Vite гнучкого API плагінів і інфраструктури Rollup значно сприяло його успіху в екосистемі. На даний момент ми вважаємо, що Rollup пропонує кращий баланс між продуктивністю і гнучкістю.

Rollup також працює над покращенням продуктивності, [перемикаючи свій парсер на SWC у версії 4](https://github.com/rollup/rollup/pull/5073). Існує також постійна робота над створенням порту Rollup на Rust під назвою Rolldown. Коли Rolldown буде готовий, він може замінити як Rollup, так і esbuild у Vite, значно покращуючи продуктивність збірки і усуваючи невідповідності між розробкою і збіркою. Ви можете переглянути [ключову доповідь Evan You на ViteConf 2023 для отримання додаткової інформації](https://youtu.be/hrdwQHoAp0M).

## Чим Vite відрізняється від X?

Ви можете ознайомитися з розділом [Порівняння](./comparisons) для отримання додаткової інформації про те, чим Vite відрізняється від інших подібних інструментів.
