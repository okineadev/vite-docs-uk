# Усунення несправностей

Дивіться [посібник з усунення несправностей Rollup](https://rollupjs.org/troubleshooting/) для отримання додаткової інформації.

Якщо запропоновані тут рішення не працюють, спробуйте опублікувати питання на [GitHub Discussions](https://github.com/vitejs/vite/discussions) або в каналі `#help` на [Vite Land Discord](https://chat.vite.dev).

## CJS

### Застаріла CJS Node API Vite

Збірка CJS Node API Vite застаріла і буде видалена у Vite 6. Дивіться [обговорення на GitHub](https://github.com/vitejs/vite/discussions/13928) для отримання додаткової інформації. Вам слід оновити свої файли або фреймворки для імпорту збірки ESM Vite.

У базовому проекті Vite переконайтеся, що:

1. Вміст файлу `vite.config.js` використовує синтаксис ESM.
2. Найближчий файл `package.json` має `"type": "module"`, або використовуйте розширення `.mjs`/`.mts`, наприклад, `vite.config.mjs` або `vite.config.mts`.

Для інших проектів є кілька загальних підходів:

- **Налаштуйте ESM за замовчуванням, увімкніть CJS за потреби:** Додайте `"type": "module"` у файл `package.json` проекту. Усі файли `*.js` тепер інтерпретуються як ESM і повинні використовувати синтаксис ESM. Ви можете перейменувати файл з розширенням `.cjs`, щоб продовжувати використовувати CJS.
- **Залиште CJS за замовчуванням, увімкніть ESM за потреби:** Якщо файл `package.json` проекту не має `"type": "module"`, усі файли `*.js` інтерпретуються як CJS. Ви можете перейменувати файл з розширенням `.mjs`, щоб використовувати ESM.
- **Динамічно імпортуйте Vite:** Якщо вам потрібно продовжувати використовувати CJS, ви можете динамічно імпортувати Vite за допомогою `import('vite')`. Це вимагає, щоб ваш код був написаний у контексті `async`, але це все ще можливо, оскільки API Vite здебільшого асинхронний.

Якщо ви не впевнені, звідки походить попередження, ви можете запустити свій скрипт з прапором `VITE_CJS_TRACE=true`, щоб записати трасування стека:

```bash
VITE_CJS_TRACE=true vite dev
```

Якщо ви хочете тимчасово ігнорувати попередження, ви можете запустити свій скрипт з прапором `VITE_CJS_IGNORE_WARNING=true`:

```bash
VITE_CJS_IGNORE_WARNING=true vite dev
```

Зверніть увагу, що файли конфігурації postcss поки не підтримують ESM + TypeScript (`.mts` або `.ts` у `"type": "module"`). Якщо у вас є конфігурації postcss з `.ts` і ви додали `"type": "module"` до package.json, вам також потрібно перейменувати конфігурацію postcss на `.cts`.

## CLI

### `Error: Cannot find module 'C:\foo\bar&baz\vite\bin\vite.js'`

Шлях до вашої папки проекту може містити `&`, що не працює з `npm` на Windows ([npm/cmd-shim#45](https://github.com/npm/cmd-shim/issues/45)).

Вам потрібно або:

- Перейти на інший менеджер пакетів (наприклад, `pnpm`, `yarn`)
- Видалити `&` з шляху до вашого проекту

## Конфігурація

### Цей пакет тільки для ESM

При імпорті пакету тільки для ESM за допомогою `require`, виникає наступна помилка.

> Не вдалося вирішити "foo". Цей пакет тільки для ESM, але його намагалися завантажити за допомогою `require`.

> Помилка [ERR_REQUIRE_ESM]: require() модуля ES /path/to/dependency.js з /path/to/vite.config.js не підтримується.
> Замість цього змініть require index.js у /path/to/vite.config.js на динамічний import(), який доступний у всіх модулях CommonJS.

У Node.js <=22 файли ESM не можуть бути завантажені за допомогою [`require`](https://nodejs.org/docs/latest-v22.x/api/esm.html#require) за замовчуванням.

Хоча це може працювати з використанням [`--experimental-require-module`](https://nodejs.org/docs/latest-v22.x/api/modules.html#loading-ecmascript-modules-using-require), або Node.js >22, або в інших середовищах, ми все ж рекомендуємо перетворити вашу конфігурацію на ESM, додавши:

- `"type": "module"` до найближчого `package.json`
- перейменувавши `vite.config.js`/`vite.config.ts` на `vite.config.mjs`/`vite.config.mts`

## Сервер розробки

### Запити зависають назавжди

Якщо ви використовуєте Linux, обмеження на кількість файлових дескрипторів та обмеження inotify можуть бути причиною проблеми. Оскільки Vite не об'єднує більшість файлів, браузери можуть запитувати багато файлів, що вимагає багато файлових дескрипторів, перевищуючи ліміт.

Щоб вирішити цю проблему:

- Збільште ліміт файлових дескрипторів за допомогою `ulimit`

  ```shell
  # Перевірте поточний ліміт
  $ ulimit -Sn
  # Змініть ліміт (тимчасово)
  $ ulimit -Sn 10000 # Можливо, вам також потрібно змінити жорсткий ліміт
  # Перезапустіть браузер
  ```

- Збільште наступні обмеження inotify за допомогою `sysctl`

  ```shell
  # Перевірте поточні обмеження
  $ sysctl fs.inotify
  # Змініть обмеження (тимчасово)
  $ sudo sysctl fs.inotify.max_queued_events=16384
  $ sudo sysctl fs.inotify.max_user_instances=8192
  $ sudo sysctl fs.inotify.max_user_watches=524288
  ```

Якщо наведені вище кроки не працюють, ви можете спробувати додати `DefaultLimitNOFILE=65536` як розкоментовану конфігурацію до наступних файлів:

- /etc/systemd/system.conf
- /etc/systemd/user.conf

Для Ubuntu Linux, можливо, вам потрібно додати рядок `* - nofile 65536` до файлу `/etc/security/limits.conf` замість оновлення конфігураційних файлів systemd.

Зверніть увагу, що ці налаштування зберігаються, але **потрібен перезапуск**.

### Мережеві запити перестають завантажуватися

При використанні самопідписаного SSL-сертифіката Chrome ігнорує всі директиви кешування та перезавантажує вміст. Vite покладається на ці директиви кешування.

Щоб вирішити проблему, використовуйте довірений SSL-сертифікат.

Дивіться: [Проблеми з кешем](https://helpx.adobe.com/mt/experience-manager/kb/cache-problems-on-chrome-with-SSL-certificate-errors.html), [Проблема Chrome](https://bugs.chromium.org/p/chromium/issues/detail?id=110649#c8)

#### macOS

Ви можете встановити довірений сертифікат через CLI за допомогою цієї команди:

```
security add-trusted-cert -d -r trustRoot -k ~/Library/Keychains/login.keychain-db your-cert.cer
```

Або, імпортувавши його в додаток Keychain Access і оновивши довіру до вашого сертифіката на "Завжди довіряти".

### 431 Request Header Fields Too Large

Коли сервер / сервер WebSocket отримує великий HTTP-заголовок, запит буде відхилено і буде показано наступне попередження.

> Сервер відповів з кодом стану 431. Дивіться https://vite.dev/guide/troubleshooting.html#_431-request-header-fields-too-large.

Це тому, що Node.js обмежує розмір заголовка запиту для пом'якшення [CVE-2018-12121](https://www.cve.org/CVERecord?id=CVE-2018-12121).

Щоб уникнути цього, спробуйте зменшити розмір заголовка запиту. Наприклад, якщо cookie довгий, видаліть його. Або ви можете використовувати [`--max-http-header-size`](https://nodejs.org/api/cli.html#--max-http-header-sizesize), щоб змінити максимальний розмір заголовка.

## HMR

### Vite виявляє зміну файлу, але HMR не працює

Ви можете імпортувати файл з іншою регістром. Наприклад, `src/foo.js` існує, а `src/bar.js` містить:

```js
import './Foo.js' // має бути './foo.js'
```

Пов'язана проблема: [#964](https://github.com/vitejs/vite/issues/964)

### Vite не виявляє зміну файлу

Якщо ви запускаєте Vite з WSL2, Vite не може відстежувати зміни файлів у деяких умовах. Дивіться [опцію `server.watch`](/config/server-options.md#server-watch).

### Замість HMR відбувається повне перезавантаження

Якщо HMR не обробляється Vite або плагіном, відбудеться повне перезавантаження, оскільки це єдиний спосіб оновити стан.

Якщо HMR обробляється, але це в межах циклічної залежності, також відбудеться повне перезавантаження для відновлення порядку виконання. Щоб вирішити це, спробуйте розірвати цикл. Ви можете запустити `vite --debug hmr`, щоб записати шлях циклічної залежності, якщо зміна файлу її викликала.

## Збірка

### Зібраний файл не працює через помилку CORS

Якщо вихідний HTML-файл був відкритий за допомогою протоколу `file`, скрипти не будуть виконуватися з наступною помилкою.

> Доступ до скрипту за адресою 'file:///foo/bar.js' з походження 'null' заблоковано політикою CORS: Крос-доменні запити підтримуються лише для схем протоколів: http, data, isolated-app, chrome-extension, chrome, https, chrome-untrusted.

> Крос-доменний запит заблоковано: Політика Same Origin забороняє читання віддаленого ресурсу за адресою file:///foo/bar.js. (Причина: запит CORS не http).

Дивіться [Причина: запит CORS не HTTP - HTTP | MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors/CORSRequestNotHttp) для отримання додаткової інформації про те, чому це відбувається.

Вам потрібно отримати доступ до файлу за допомогою протоколу `http`. Найпростіший спосіб досягти цього - запустити `npx vite preview`.

## Оптимізовані залежності

### Застарілі попередньо зібрані залежності при посиланні на локальний пакет

Ключ хешу, який використовується для анулювання оптимізованих залежностей, залежить від вмісту блокування пакету, застосованих патчів до залежностей та параметрів у файлі конфігурації Vite, які впливають на об'єднання модулів node. Це означає, що Vite виявить, коли залежність перевизначена за допомогою такої функції, як [npm overrides](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#overrides), і повторно об'єднає ваші залежності при наступному запуску сервера. Vite не анулює залежності, коли ви використовуєте таку функцію, як [npm link](https://docs.npmjs.com/cli/v9/commands/npm-link). У разі посилання або відключення залежності, вам потрібно буде примусово повторно оптимізувати при наступному запуску сервера за допомогою `vite --force`. Ми рекомендуємо використовувати перевизначення замість цього, які тепер підтримуються кожним менеджером пакетів (дивіться також [pnpm overrides](https://pnpm.io/package_json#pnpmoverrides) і [yarn resolutions](https://yarnpkg.com/configuration/manifest/#resolutions)).

## Вузькі місця продуктивності

Якщо у вас виникають проблеми з продуктивністю додатка, що призводять до повільного завантаження, ви можете запустити вбудований інспектор Node.js з вашим сервером розробки Vite або при збірці вашого додатка для створення профілю ЦП:

::: code-group

```bash [сервер розробки]
vite --profile --open
```

```bash [збірка]
vite build --profile
```

:::

::: tip Сервер розробки Vite
Як тільки ваш додаток відкриється в браузері, просто дочекайтеся завершення завантаження, а потім поверніться до терміналу і натисніть клавішу `p` (зупинить інспектор Node.js), потім натисніть клавішу `q`, щоб зупинити сервер розробки.
:::

Інспектор Node.js створить `vite-profile-0.cpuprofile` у кореневій папці, перейдіть на https://www.speedscope.app/ і завантажте профіль ЦП за допомогою кнопки `BROWSE`, щоб переглянути результат.

Ви можете встановити [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect), який дозволяє вам перевіряти проміжний стан плагінів Vite і також може допомогти вам визначити, які плагіни або проміжні програмні засоби є вузьким місцем у ваших додатках. Плагін можна використовувати як у режимі розробки, так і в режимі збірки. Перевірте файл readme для отримання додаткової інформації.

## Інше

### Модуль екстерналізовано для сумісності з браузером

Коли ви використовуєте модуль Node.js у браузері, Vite виведе наступне попередження.

> Модуль "fs" екстерналізовано для сумісності з браузером. Неможливо отримати доступ до "fs.readFile" у клієнтському коді.

Це тому, що Vite не автоматично додає поліфіли для модулів Node.js.

Ми рекомендуємо уникати модулів Node.js для коду браузера, щоб зменшити розмір пакету, хоча ви можете додати поліфіли вручну. Якщо модуль імпортується з бібліотеки третьої сторони (яка призначена для використання в браузері), рекомендується повідомити про проблему відповідній бібліотеці.

### Виникає синтаксична помилка / помилка типу

Vite не може обробляти і не підтримує код, який працює тільки в режимі без строгого режиму (sloppy mode). Це тому, що Vite використовує ESM, і це завжди [строгий режим](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) всередині ESM.

Наприклад, ви можете побачити ці помилки.

> [ERROR] With statements cannot be used with the "esm" output format due to strict mode

> TypeError: Cannot create property 'foo' on boolean 'false'

Якщо ці коди використовуються всередині залежностей, ви можете використовувати [`patch-package`](https://github.com/ds300/patch-package) (або [`yarn patch`](https://yarnpkg.com/cli/patch) або [`pnpm patch`](https://pnpm.io/cli/patch)) як вихід.

### Розширення браузера

Деякі розширення браузера (наприклад, блокувальники реклами) можуть перешкоджати клієнту Vite надсилати запити на сервер розробки Vite. У цьому випадку ви можете побачити білий екран без зареєстрованих помилок. Спробуйте вимкнути розширення, якщо у вас виникла ця проблема.

### Перехресні посилання на диски в Windows

Якщо у вашому проекті є перехресні посилання на диски в Windows, Vite може не працювати.

Прикладом перехресних посилань на диски є:

- віртуальний диск, пов'язаний з папкою за допомогою команди `subst`
- символічне посилання/з'єднання на інший диск за допомогою команди `mklink` (наприклад, глобальний кеш Yarn)

Пов'язана проблема: [#10802](https://github.com/vitejs/vite/issues/10802)
