# API середовища для плагінів

:::warning Експериментально
Початкова робота над цим API була представлена у Vite 5.1 під назвою "Vite Runtime API". Цей посібник описує переглянуте API, перейменоване на Environment API. Це API буде випущено у Vite 6 як експериментальне. Ви вже можете протестувати його у останній версії `vite@6.0.0-beta.x`.

Ресурси:

- [Обговорення зворотного зв'язку](https://github.com/vitejs/vite/discussions/16358), де ми збираємо відгуки про нові API.
- [PR Environment API](https://github.com/vitejs/vite/pull/16471), де нове API було реалізовано та переглянуто.

Будь ласка, поділіться з нами своїми відгуками, тестуючи пропозицію.
:::

## Доступ до поточного середовища в хуках

Оскільки до Vite 6 було лише два середовища (`client` і `ssr`), `ssr` булевий параметр був достатнім для ідентифікації поточного середовища в API Vite. Хуки плагінів отримували `ssr` булевий параметр у останньому параметрі опцій, і кілька API очікували необов'язковий останній параметр `ssr` для правильного асоціювання модулів з правильним середовищем (наприклад, `server.moduleGraph.getModuleByUrl(url, { ssr })`).

З появою конфігурованих середовищ ми тепер маємо уніфікований спосіб доступу до їхніх опцій та екземплярів у плагінах. Хуки плагінів тепер надають `this.environment` у своєму контексті, і API, які раніше очікували `ssr` булевий параметр, тепер прив'язані до відповідного середовища (наприклад, `environment.moduleGraph.getModuleByUrl(url)`).

Сервер Vite має спільний конвеєр плагінів, але коли модуль обробляється, це завжди робиться в контексті даного середовища. Екземпляр `environment` доступний у контексті плагіна.

Плагін може використовувати екземпляр `environment` для зміни способу обробки модуля залежно від конфігурації для середовища (яка може бути доступна за допомогою `environment.config`).

```ts
  transform(code, id) {
    console.log(this.environment.config.resolve.conditions)
  }
```

## Реєстрація нових середовищ за допомогою хуків

Плагіни можуть додавати нові середовища у хуці `config` (наприклад, щоб мати окремий граф модулів для [RSC](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components)):

```ts
  config(config: UserConfig) {
    config.environments.rsc ??= {}
  }
```

Порожній об'єкт достатній для реєстрації середовища, значення за замовчуванням беруться з конфігурації середовища на кореневому рівні.

## Конфігурація середовища за допомогою хуків

Поки хук `config` виконується, повний список середовищ ще не відомий, і середовища можуть бути змінені як значеннями за замовчуванням з конфігурації середовища на кореневому рівні, так і явно через запис `config.environments`.
Плагіни повинні встановлювати значення за замовчуванням за допомогою хуку `config`. Щоб налаштувати кожне середовище, вони можуть використовувати новий хук `configEnvironment`. Цей хук викликається для кожного середовища з його частково вирішеною конфігурацією, включаючи остаточні значення за замовчуванням.

```ts
  configEnvironment(name: string, options: EnvironmentOptions) {
    if (name === 'rsc') {
      options.resolve.conditions = // ...
```

## Хук `hotUpdate`

- **Тип:** `(this: { environment: DevEnvironment }, options: HotUpdateOptions) => Array<EnvironmentModuleNode> | void | Promise<Array<EnvironmentModuleNode> | void>`
- **Див. також:** [HMR API](./api-hmr)

Хук `hotUpdate` дозволяє плагінам виконувати користувацьку обробку оновлень HMR для даного середовища. Коли файл змінюється, алгоритм HMR виконується для кожного середовища послідовно відповідно до порядку в `server.environments`, тому хук `hotUpdate` буде викликаний кілька разів. Хук отримує об'єкт контексту з наступним підписом:

```ts
interface HotUpdateContext {
  type: 'create' | 'update' | 'delete'
  file: string
  timestamp: number
  modules: Array<EnvironmentModuleNode>
  read: () => string | Promise<string>
  server: ViteDevServer
}
```

- `this.environment` - це середовище виконання модуля, де в даний момент обробляється оновлення файлу.

- `modules` - це масив модулів у цьому середовищі, які постраждали від зміненого файлу. Це масив, оскільки один файл може відповідати кільком сервісним модулям (наприклад, Vue SFC).

- `read` - це асинхронна функція читання, яка повертає вміст файлу. Це надається тому, що на деяких системах зворотний виклик зміни файлу може спрацювати занадто швидко, перш ніж редактор завершить оновлення файлу, і прямий `fs.readFile` поверне порожній вміст. Функція читання, що передається, нормалізує цю поведінку.

Хук може вибрати:

- Фільтрувати та звужувати список постраждалих модулів, щоб HMR був більш точним.

- Повернути порожній масив і виконати повне перезавантаження:

  ```js
  hotUpdate({ modules, timestamp }) {
    if (this.environment.name !== 'client')
      return

    // Ручне інвалідовання модулів
    const invalidatedModules = new Set()
    for (const mod of modules) {
      this.environment.moduleGraph.invalidateModule(
        mod,
        invalidatedModules,
        timestamp,
        true
      )
    }
    this.environment.hot.send({ type: 'full-reload' })
    return []
  }
  ```

- Повернути порожній масив і виконати повну користувацьку обробку HMR, відправивши користувацькі події на клієнт:

  ```js
  hotUpdate() {
    if (this.environment.name !== 'client')
      return

    this.environment.hot.send({
      type: 'custom',
      event: 'special-update',
      data: {}
    })
    return []
  }
  ```

  Клієнтський код повинен зареєструвати відповідний обробник за допомогою [HMR API](./api-hmr) (це може бути вставлено хуком `transform` того ж плагіна):

  ```js
  if (import.meta.hot) {
    import.meta.hot.on('special-update', (data) => {
      // виконати користувацьке оновлення
    })
  }
  ```

## Плагіни для кожного середовища

Плагін може визначити, до яких середовищ він повинен застосовуватися за допомогою функції `applyToEnvironment`.

```js
const UnoCssPlugin = () => {
  // спільний глобальний стан
  return {
    buildStart() {
      // ініціалізація стану для кожного середовища за допомогою WeakMap<Environment,Data>
      // використовуючи this.environment
    },
    configureServer() {
      // використовуйте глобальні хуки як зазвичай
    },
    applyToEnvironment(environment) {
      // поверніть true, якщо цей плагін повинен бути активним у цьому середовищі
      // якщо хук не використовується, плагін активний у всіх середовищах
    },
    resolveId(id, importer) {
      // викликається тільки для середовищ, до яких застосовується цей плагін
    },
  }
}
```

## Середовище в хуках збірки

Так само, як і під час розробки, хуки плагінів також отримують екземпляр середовища під час збірки, замінюючи булевий параметр `ssr`.
Це також працює для `renderChunk`, `generateBundle` та інших хуків, що використовуються тільки під час збірки.

## Спільні плагіни під час збірки

До Vite 6, конвеєри плагінів працювали по-різному під час розробки та збірки:

- **Під час розробки:** плагіни спільні
- **Під час збірки:** плагіни ізольовані для кожного середовища (у різних процесах: `vite build` потім `vite build --ssr`).

Це змушувало фреймворки ділитися станом між збіркою `client` та збіркою `ssr` через файли маніфесту, записані у файлову систему. У Vite 6 ми тепер збираємо всі середовища в одному процесі, тому спосіб роботи конвеєра плагінів та міжсередовищної комунікації може бути узгоджений з розробкою.

У майбутньому великому випуску (Vite 7 або 8) ми прагнемо до повного узгодження:

- **Під час розробки та збірки:** плагіни спільні, з [фільтрацією за середовищем](#плагіни-для-кожного-середовища)

Також буде єдиний екземпляр `ResolvedConfig`, спільний під час збірки, що дозволить кешувати на рівні всього процесу збірки додатка так само, як ми робили з `WeakMap<ResolvedConfig, CachedData>` під час розробки.

Для Vite 6 нам потрібно зробити менший крок, щоб зберегти зворотну сумісність. Плагіни екосистеми наразі використовують `config.build` замість `environment.config.build` для доступу до конфігурації, тому нам потрібно створити новий `ResolvedConfig` для кожного середовища за замовчуванням. Проект може вибрати спільне використання повної конфігурації та конвеєра плагінів, встановивши `builder.sharedConfigBuild` у `true`.

Ця опція спочатку працюватиме лише для невеликої підмножини проектів, тому автори плагінів можуть вибрати спільне використання конкретного плагіна, встановивши прапорець `sharedDuringBuild` у `true`. Це дозволяє легко ділитися станом як для звичайних плагінів:

```js
function myPlugin() {
  // Спільний стан між усіма середовищами під час розробки та збірки
  const sharedState = ...
  return {
    name: 'shared-plugin',
    transform(code, id) { ... },

    // Вибір єдиного екземпляра для всіх середовищ
    sharedDuringBuild: true,
  }
}
```
