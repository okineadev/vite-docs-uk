# Опції збірки

Якщо не зазначено інше, опції в цьому розділі застосовуються лише до збірки.

## build.target

- **Тип:** `string | string[]`
- **За замовчуванням:** `'modules'`
- **Пов'язано:** [Сумісність з браузерами](/guide/build#browser-compatibility)

Цільова сумісність браузера для кінцевого пакету. Значення за замовчуванням - це спеціальне значення Vite, `'modules'`, яке орієнтоване на браузери з [нативними ES модулями](https://caniuse.com/es6-module), [нативним динамічним імпортом ESM](https://caniuse.com/es6-module-dynamic-import) та підтримкою [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta). Vite замінить `'modules'` на `['es2020', 'edge88', 'firefox78', 'chrome87', 'safari14']`.

Інше спеціальне значення - `'esnext'`, яке передбачає підтримку нативних динамічних імпортів і буде виконувати лише мінімальну транспіляцію.

Трансформація виконується за допомогою esbuild, і значення повинно бути дійсним [опцією цілі esbuild](https://esbuild.github.io/api/#target). Користувацькі цілі можуть бути або версією ES (наприклад, `es2015`), або браузером з версією (наприклад, `chrome58`), або масивом кількох цільових рядків.

Збірка не вдасться, якщо код містить функції, які не можуть бути безпечно транспільовані за допомогою esbuild. Дивіться [документацію esbuild](https://esbuild.github.io/content-types/#javascript) для отримання додаткової інформації.

## build.modulePreload

- **Тип:** `boolean | { polyfill?: boolean, resolveDependencies?: ResolveModulePreloadDependenciesFn }`
- **За замовчуванням:** `{ polyfill: true }`

За замовчуванням автоматично вставляється [поліфіл попереднього завантаження модулів](https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill). Поліфіл автоматично вставляється в проксі-модуль кожного `index.html` входу. Якщо збірка налаштована на використання нестандартного входу без HTML через `build.rollupOptions.input`, то необхідно вручну імпортувати поліфіл у вашому нестандартному вході:

```js
import 'vite/modulepreload-polyfill'
```

Примітка: поліфіл **не** застосовується до [режиму бібліотеки](/guide/build#library-mode). Якщо вам потрібно підтримувати браузери без нативного динамічного імпорту, вам, ймовірно, слід уникати його використання у вашій бібліотеці.

Поліфіл можна вимкнути, використовуючи `{ polyfill: false }`.

Список фрагментів для попереднього завантаження для кожного динамічного імпорту обчислюється Vite. За замовчуванням, абсолютний шлях, включаючи `base`, буде використовуватися при завантаженні цих залежностей. Якщо `base` є відносним (`''` або `'./'`), `import.meta.url` використовується під час виконання, щоб уникнути абсолютних шляхів, які залежать від кінцевої розгорнутої бази.

Існує експериментальна підтримка для тонкого контролю над списком залежностей та їх шляхами за допомогою функції `resolveDependencies`. [Дайте відгук](https://github.com/vitejs/vite/discussions/13841). Вона очікує функцію типу `ResolveModulePreloadDependenciesFn`:

```ts
type ResolveModulePreloadDependenciesFn = (
  url: string,
  deps: string[],
  context: {
    hostId: string
    hostType: 'html' | 'js'
  },
) => string[]
```

Функція `resolveDependencies` буде викликатися для кожного динамічного імпорту зі списком фрагментів, від яких він залежить, і також буде викликатися для кожного фрагмента, імпортованого у вхідні HTML файли. Можна повернути новий масив залежностей з відфільтрованими або додатковими залежностями, а їхні шляхи можуть бути змінені. Шляхи `deps` є відносними до `build.outDir`. Повернене значення повинно бути відносним шляхом до `build.outDir`.

```js twoslash
/** @type {import('vite').UserConfig} */
const config = {
  // prettier-ignore
  build: {
// ---cut-before---
modulePreload: {
  resolveDependencies: (filename, deps, { hostId, hostType }) => {
    return deps.filter(condition)
  },
},
// ---cut-after---
  },
}
```

Шляхи вирішених залежностей можуть бути додатково змінені за допомогою [`experimental.renderBuiltUrl`](../guide/build.md#advanced-base-options).

## build.polyfillModulePreload

- **Тип:** `boolean`
- **За замовчуванням:** `true`
- **Застаріло** використовуйте `build.modulePreload.polyfill` замість цього

Чи слід автоматично вставляти [поліфіл попереднього завантаження модулів](https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill).

## build.outDir

- **Тип:** `string`
- **За замовчуванням:** `dist`

Вкажіть вихідний каталог (відносно [кореня проекту](/guide/#index-html-and-project-root)).

## build.assetsDir

- **Тип:** `string`
- **За замовчуванням:** `assets`

Вкажіть каталог для вкладення згенерованих ресурсів (відносно `build.outDir`. Це не використовується в [режимі бібліотеки](/guide/build#library-mode)).

## build.assetsInlineLimit

- **Тип:** `number` | `((filePath: string, content: Buffer) => boolean | undefined)`
- **За замовчуванням:** `4096` (4 КіБ)

Імпортовані або посилання на ресурси, які менші за цей поріг, будуть вбудовані як base64 URL, щоб уникнути додаткових HTTP запитів. Встановіть значення `0`, щоб повністю вимкнути вбудовування.

Якщо передано зворотний виклик, можна повернути булеве значення для включення або виключення. Якщо нічого не повернуто, застосовується логіка за замовчуванням.

Плейсхолдери Git LFS автоматично виключаються з вбудовування, оскільки вони не містять вмісту файлу, який вони представляють.

::: tip Примітка
Якщо ви вказуєте `build.lib`, `build.assetsInlineLimit` буде ігноруватися, і ресурси завжди будуть вбудовані, незалежно від розміру файлу або наявності плейсхолдерів Git LFS.
:::

## build.cssCodeSplit

- **Тип:** `boolean`
- **За замовчуванням:** `true`

Увімкнути/вимкнути розділення CSS коду. Коли увімкнено, CSS, імпортований в асинхронні JS фрагменти, буде збережено як фрагменти і завантажено разом з фрагментом.

Якщо вимкнено, весь CSS у всьому проекті буде витягнуто в один CSS файл.

::: tip Примітка
Якщо ви вказуєте `build.lib`, `build.cssCodeSplit` буде `false` за замовчуванням.
:::

## build.cssTarget

- **Тип:** `string | string[]`
- **За замовчуванням:** те ж саме, що і [`build.target`](#buildtarget)

Ця опція дозволяє користувачам встановити іншу цільову сумісність браузера для мінімізації CSS, ніж ту, що використовується для транспіляції JavaScript.

Її слід використовувати лише тоді, коли ви орієнтуєтеся на нестандартний браузер.
Одним із прикладів є Android WeChat WebView, який підтримує більшість сучасних функцій JavaScript, але не підтримує [шістнадцяткове позначення кольору `#RGBA` в CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb_colors).
У цьому випадку вам потрібно встановити `build.cssTarget` на `chrome61`, щоб запобігти перетворенню `rgba()` кольорів у шістнадцяткові позначення `#RGBA`.

## build.cssMinify

- **Тип:** `boolean | 'esbuild' | 'lightningcss'`
- **За замовчуванням:** те ж саме, що і [`build.minify`](#buildminify) для клієнта, `'esbuild'` для SSR

Ця опція дозволяє користувачам перевизначити мінімізацію CSS окремо, замість використання значення за замовчуванням `build.minify`, щоб ви могли налаштувати мінімізацію для JS і CSS окремо. Vite за замовчуванням використовує `esbuild` для мінімізації CSS. Встановіть опцію на `'lightningcss'`, щоб використовувати [Lightning CSS](https://lightningcss.dev/minification.html) замість цього. Якщо вибрано, його можна налаштувати за допомогою [`css.lightningcss`](./shared-options.md#css-lightningcss).

## build.sourcemap

- **Тип:** `boolean | 'inline' | 'hidden'`
- **За замовчуванням:** `false`

Генерувати мапи джерел для продакшн-збірки. Якщо `true`, буде створено окремий файл мапи джерел. Якщо `'inline'`, мапа джерел буде додана до вихідного файлу як data URI. `'hidden'` працює як `true`, але відповідні коментарі мапи джерел у зібраних файлах будуть приховані.

## build.rollupOptions

- **Тип:** [`RollupOptions`](https://rollupjs.org/configuration-options/)

Безпосередньо налаштуйте основний пакет Rollup. Це те саме, що і опції, які можна експортувати з конфігураційного файлу Rollup, і вони будуть об'єднані з внутрішніми опціями Rollup від Vite. Дивіться [документацію Rollup](https://rollupjs.org/configuration-options/) для отримання додаткової інформації.

## build.commonjsOptions

- **Тип:** [`RollupCommonJSOptions`](https://github.com/rollup/plugins/tree/master/packages/commonjs#options)

Опції для передачі в [@rollup/plugin-commonjs](https://github.com/rollup/plugins/tree/master/packages/commonjs).

## build.dynamicImportVarsOptions

- **Тип:** [`RollupDynamicImportVarsOptions`](https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#options)
- **Пов'язано:** [Динамічний імпорт](/guide/features#dynamic-import)

Опції для передачі в [@rollup/plugin-dynamic-import-vars](https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars).

## build.lib

- **Тип:** `{ entry: string | string[] | { [entryAlias: string]: string }, name?: string, formats?: ('es' | 'cjs' | 'umd' | 'iife')[], fileName?: string | ((format: ModuleFormat, entryName: string) => string), cssFileName?: string }`
- **Пов'язано:** [Режим бібліотеки](/guide/build#library-mode)

Збірка як бібліотека. `entry` є обов'язковим, оскільки бібліотека не може використовувати HTML як вхідну точку. `name` - це глобальна змінна, яка буде доступна, і є обов'язковою, коли `formats` включає `'umd'` або `'iife'`. Формати за замовчуванням - це `['es', 'umd']`, або `['es', 'cjs']`, якщо використовується кілька вхідних точок.

`fileName` - це ім'я вихідного файлу пакету, яке за замовчуванням відповідає `"name"` у `package.json`. Його також можна визначити як функцію, яка приймає `format` і `entryName` як аргументи і повертає ім'я файлу.

Якщо ваш пакет імпортує CSS, `cssFileName` можна використовувати для вказівки імені вихідного файлу CSS. За замовчуванням воно відповідає значенню `fileName`, якщо воно встановлено як рядок, інакше воно також повертається до `"name"` у `package.json`.

```js twoslash [vite.config.js]
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    lib: {
      entry: ['src/main.js'],
      fileName: (format, entryName) => `my-lib-${entryName}.${format}.js`,
      cssFileName: 'my-lib-style',
    },
  },
})
```

## build.manifest

- **Тип:** `boolean | string`
- **За замовчуванням:** `false`
- **Пов'язано:** [Інтеграція з бекендом](/guide/backend-integration)

Коли встановлено `true`, збірка також створить файл `.vite/manifest.json`, який містить відповідність між іменами файлів ресурсів без хешу та їх хешованими версіями, які потім можуть бути використані серверним фреймворком для рендерингу правильних посилань на ресурси. Коли значення є рядком, воно буде використано як ім'я файлу маніфесту.

## build.ssrManifest

- **Тип:** `boolean | string`
- **За замовчуванням:** `false`
- **Пов'язано:** [Рендеринг на стороні сервера](/guide/ssr)

Коли встановлено `true`, збірка також створить маніфест SSR для визначення посилань на стилі та директив попереднього завантаження ресурсів у продакшн. Коли значення є рядком, воно буде використано як ім'я файлу маніфесту.

## build.ssr

- **Тип:** `boolean | string`
- **За замовчуванням:** `false`
- **Пов'язано:** [Рендеринг на стороні сервера](/guide/ssr)

Створити збірку, орієнтовану на SSR. Значення може бути рядком для безпосереднього вказання вхідної точки SSR, або `true`, що вимагає вказання вхідної точки SSR через `rollupOptions.input`.

## build.emitAssets

- **Тип:** `boolean`
- **За замовчуванням:** `false`

Під час збірок, не орієнтованих на клієнт, статичні ресурси не створюються, оскільки передбачається, що вони будуть створені як частина клієнтської збірки. Ця опція дозволяє фреймворкам примусово створювати їх в інших середовищах збірки. Відповідальність за об'єднання ресурсів після збірки лежить на фреймворку.

## build.ssrEmitAssets

- **Тип:** `boolean`
- **За замовчуванням:** `false`

Під час збірки SSR статичні ресурси не створюються, оскільки передбачається, що вони будуть створені як частина клієнтської збірки. Ця опція дозволяє фреймворкам примусово створювати їх як у клієнтській, так і в SSR збірці. Відповідальність за об'єднання ресурсів після збірки лежить на фреймворку. Ця опція буде замінена на `build.emitAssets`, коли API середовища стане стабільним.

## build.minify

- **Тип:** `boolean | 'terser' | 'esbuild'`
- **За замовчуванням:** `'esbuild'` для клієнтської збірки, `false` для SSR збірки

Встановіть `false`, щоб вимкнути мінімізацію, або вкажіть мінімізатор для використання. За замовчуванням використовується [esbuild](https://github.com/evanw/esbuild), який у 20 ~ 40 разів швидший за terser і лише на 1 ~ 2% гірший за стиснення. [Бенчмарки](https://github.com/privatenumber/minification-benchmarks)

Зверніть увагу, що опція `build.minify` не мінімізує пробіли при використанні формату `'es'` у режимі бібліотеки, оскільки це видаляє чисті анотації та порушує tree-shaking.

Terser повинен бути встановлений, коли встановлено значення `'terser'`.

```sh
npm add -D terser
```

## build.terserOptions

- **Тип:** `TerserOptions`

Додаткові [опції мінімізації](https://terser.org/docs/api-reference#minify-options) для передачі в Terser.

Крім того, ви також можете передати опцію `maxWorkers: number`, щоб вказати максимальну кількість робітників для створення. За замовчуванням це кількість процесорів мінус 1.

## build.write

- **Тип:** `boolean`
- **За замовчуванням:** `true`

Встановіть `false`, щоб вимкнути запис пакету на диск. Це в основному використовується у [програмних викликах `build()`](/guide/api-javascript#build), де потрібна подальша обробка пакету перед записом на диск.

## build.emptyOutDir

- **Тип:** `boolean`
- **За замовчуванням:** `true`, якщо `outDir` знаходиться всередині `root`

За замовчуванням Vite очистить `outDir` під час збірки, якщо він знаходиться всередині кореня проекту. Він видасть попередження, якщо `outDir` знаходиться поза коренем, щоб уникнути випадкового видалення важливих файлів. Ви можете явно встановити цю опцію, щоб придушити попередження. Це також доступно через командний рядок як `--emptyOutDir`.

## build.copyPublicDir

- **Тип:** `boolean`
- **За замовчуванням:** `true`

За замовчуванням Vite копіює файли з `publicDir` у `outDir` під час збірки. Встановіть значення `false`, щоб вимкнути це.

## build.reportCompressedSize

- **Тип:** `boolean`
- **За замовчуванням:** `true`

Увімкнути/вимкнути звітування про розмір стиснення gzip. Стиснення великих вихідних файлів може бути повільним, тому вимкнення цього може підвищити продуктивність збірки для великих проектів.

## build.chunkSizeWarningLimit

- **Тип:** `number`
- **За замовчуванням:** `500`

Обмеження для попереджень про розмір фрагментів (у КБ). Воно порівнюється з некомпресованим розміром фрагменту, оскільки [розмір JavaScript безпосередньо пов'язаний з часом виконання](https://v8.dev/blog/cost-of-javascript-2019).

## build.watch

- **Тип:** [`WatcherOptions`](https://rollupjs.org/configuration-options/#watch)`| null`
- **За замовчуванням:** `null`

Встановіть `{}`, щоб увімкнути спостерігач Rollup. Це в основному використовується у випадках, що включають лише плагіни збірки або інтеграційні процеси.

::: warning Використання Vite на Windows Subsystem for Linux (WSL) 2

Існують випадки, коли спостереження за файловою системою не працює з WSL2.
Дивіться [`server.watch`](./server-options.md#server-watch) для отримання додаткової інформації.

:::
